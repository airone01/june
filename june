#!/usr/bin/env bash
# june - prototype user-space package manager for junest environments
# Prototype features:
#  - june install <pkg>       : install small package via yay (inside junest)
#  - june installft <user/env|env|/path/to/tar> : install "fat" environment (tarball)
#  - june list-envs           : list available fat envs exposed under /sgoinfre/*/june/envs
#  - june installed           : list installed fat envs for this user (session state file)
#  - june uninstallft <env>   : uninstall a previously installft'ed env
# Notes:
#  - This is a prototype / starting point. It prefers fat env tarballs that place
#    their files under /opt/envs/<envname>/ inside the tarball for easy uninstall.
#  - To "expose" an env from a student's shared directory, that student's
#    /sgoinfre/<username>/june/ should contain a file named `june.proof`.
#    Only envs under users that provide june.proof are considered available.
#  - State is tracked in $STATE_DB as a simple pipe-delimited list.

set -euo pipefail
IFS=$'\n\t'

# --- Configuration ---
SGOINFRE_LINK="${HOME}/sgoinfre"    # typically a symlink to /sgoinfre/<USER>
SGOINFRE_BASE="/sgoinfre"           # where other users' sgoinfre dirs live
GOINFRE="${HOME}/goinfre"
JUNEST_ROOT="${GOINFRE}/junest-root"
SHIMS_DIR="${HOME}/bin"
STATE_DB="${GOINFRE}/june-state.db"   # simple state file (pipe-delimited)
JUNEST_CMD="$(command -v junest 2>/dev/null || true)"
YAY_CMD="yay"

# Create dirs if needed
mkdir -p "$SHIMS_DIR" "$JUNEST_ROOT"
touch "$STATE_DB"

# --- Helpers ---
log() { printf '%s\n' "[june] $*"; }
err() { printf '%s\n' "[june] ERROR: $*" >&2; }

ensure_junest() {
  if [[ -z "$JUNEST_CMD" ]]; then
    err "junest not found in PATH. Install junest (e.g. in ~/.local/bin) first."; return 1
  fi
}

state_add() {
  # state line format: env|user|tarball|installed_at|binaries_comma_separated
  local env="$1"; local user="$2"; local tarball="$3"; local bins="$4"
  local now; now=$(date -Iseconds)
  printf '%s|%s|%s|%s|%s\n' "$env" "$user" "$tarball" "$now" "$bins" >> "$STATE_DB"
}

state_find() {
  local env="$1"
  grep -F "^${env}|" "$STATE_DB" || true
}

state_remove() {
  local env="$1"
  if [[ -z $(state_find "$env") ]]; then
    return 1
  fi
  # rewrite file without matching env
  grep -F -v "^${env}|" "$STATE_DB" > "$STATE_DB.tmp" && mv "$STATE_DB.tmp" "$STATE_DB"
}

# create a shim in $SHIMS_DIR for an executable inside junest root
create_shim() {
  local target_path="$1"   # absolute path inside junest root, e.g. /opt/envs/foo/bin/code
  local name="$2"
  local shim_file="${SHIMS_DIR}/${name}"
  cat > "$shim_file" <<EOF
#!/usr/bin/env bash
#june-shim
# Auto-generated by june
export JUNEST_ROOT_DIR="${JUNEST_ROOT}"
exec ${JUNEST_CMD} -- "${target_path}" "\$@"
EOF
  chmod +x "$shim_file"
  log "shim created: $shim_file -> $target_path"
}

# scan for executables under a directory and generate shims
generate_shims_for_env() {
  local envname="$1"; local envdir="$2"  # envdir is absolute inside junest root, e.g. $JUNEST_ROOT/opt/envs/$envname
  local bindir
  for bindir in "$envdir/bin" "$envdir/usr/bin"; do
    if [[ -d "$bindir" ]]; then
      while IFS= read -r -d '' exe; do
        local binname; binname=$(basename "$exe")
        create_shim "${envdir}/${exe#${envdir}/}" "$binname"
      done < <(find "$bindir" -type f -perm -u=x -print0 || true)
    fi
  done
}

# list available fat envs from /sgoinfre/*/june/envs that are exposed (june.proof present)
list_available_envs() {
  log "Scanning ${SGOINFRE_BASE}/*/june/envs for exposed envs (requires june.proof in the user's june dir)..."
  shopt -s nullglob
  for userdir in ${SGOINFRE_BASE}/*; do
    local user; user=$(basename "$userdir")
    local proof="${userdir}/june/june.proof"
    if [[ ! -f "$proof" ]]; then
      continue
    fi
    local envdir="${userdir}/june/envs"
    if [[ -d "$envdir" ]]; then
      for tar in "$envdir"/*.tar.* "$envdir"/*.tar; do
        [[ -e "$tar" ]] || continue
        local base; base=$(basename "$tar")
        # heuristics to extract envname from filename env-<name> or <name>.tar.zst
        local envname
        if [[ "$base" =~ env-([a-zA-Z0-9._-]+) ]]; then
          envname="${BASH_REMATCH[1]}"
        else
          envname="${base%%.tar.*}"
        fi
        printf '%s\t%s\t%s\n' "$user" "$envname" "$tar"
      done
    fi
  done
  shopt -u nullglob
}

# find tarball for user/env or search across users
find_env_tarball() {
  local identifier="$1"
  # if path given
  if [[ -f "$identifier" ]]; then
    echo "$identifier"; return 0
  fi
  # if user/env form
  if [[ "$identifier" == */* ]]; then
    local user=${identifier%%/*}
    local env=${identifier#*/}
    local candidate_dir="${SGOINFRE_BASE}/${user}/june/envs"
    if [[ ! -f "${SGOINFRE_BASE}/${user}/june/june.proof" ]]; then
      err "user '$user' does not expose envs (missing june.proof)"; return 1
    fi
    if [[ -d "$candidate_dir" ]]; then
      shopt -s nullglob
      for tar in "$candidate_dir"/*${env}*.tar.* "$candidate_dir"/${env}.tar.* "$candidate_dir"/${env}.tar; do
        [[ -e "$tar" ]] || continue
        echo "$tar"; shopt -u nullglob; return 0
      done
      shopt -u nullglob
    fi
    err "no tarball found for $identifier"; return 1
  fi
  # otherwise search across all users with june.proof
  shopt -s nullglob
  for userdir in ${SGOINFRE_BASE}/*; do
    local user; user=$(basename "$userdir")
    local proof="${userdir}/june/june.proof"
    if [[ ! -f "$proof" ]]; then
      continue
    fi
    local envdir="${userdir}/june/envs"
    if [[ -d "$envdir" ]]; then
      for tar in "$envdir"/*${identifier}*.tar.* "$envdir"/${identifier}.tar.* "$envdir"/${identifier}.tar; do
        [[ -e "$tar" ]] || continue
        echo "$tar"; shopt -u nullglob; return 0
      done
    fi
  done
  shopt -u nullglob
  err "no tarball found for env '$identifier'"; return 1
}

# atomic extract of tarball into target envdir inside JUNEST_ROOT
extract_env_tarball() {
  local tarball="$1"
  local tmp; tmp=$(mktemp -d "${GOINFRE}/june-tmp.XXXX")
  log "extracting $tarball into temporary dir $tmp"
  if [[ "$tarball" == *.zst ]]; then
    tar --use-compress-program=unzstd -xpf "$tarball" -C "$tmp"
  else
    tar -xpf "$tarball" -C "$tmp"
  fi
  # prefer if tarball contains opt/envs/<env>
  if [[ -d "$tmp/opt/envs" ]]; then
    mkdir -p "$JUNEST_ROOT/opt/envs"
    # move all env dirs found under tmp/opt/envs into junest root
    for d in "$tmp/opt/envs"/*; do
      [[ -e "$d" ]] || continue
      local envname; envname=$(basename "$d")
      mv "$d" "$JUNEST_ROOT/opt/envs/"
      log "moved env $envname -> ${JUNEST_ROOT}/opt/envs/$envname"
    done
  else
    # fallback: merge whole tmp into JUNEST_ROOT (may overwrite)
    log "tarball did not contain opt/envs/. merging into ${JUNEST_ROOT} (may overwrite)"
    cp -a "$tmp/." "$JUNEST_ROOT/"
  fi
  rm -rf "$tmp"
}

# --- Commands ---
cmd_install() {
  local pkg="$1"
  ensure_junest || return 1
  log "Note: prefer installing 'package-bin' variants when available to avoid building AUR from source."
  log "Installing $pkg inside junest via yay/pacman (this may take a while)..."
  if [[ -n "$YAY_CMD" ]]; then
    ${JUNEST_CMD} -- ${YAY_CMD} -S --noconfirm "$pkg" || { err "install failed"; return 1; }
  else
    ${JUNEST_CMD} -- pacman -S --noconfirm "$pkg" || { err "install failed"; return 1; }
  fi
  log "Install finished. Generating shims for common bin dirs..."
  local bins; bins=$(${JUNEST_CMD} -- ${YAY_CMD} -Ql "$pkg"|grep bin|grep -v '/$'|sed 's/.* //'|sed '/^[[:space:]]*$/d')
  for bin_path in "${bins}"; do
    local bin_name; bin_name=$(echo ${bin_path}|sed 's/.*\///')
    log "Linking shim '${bin_name}' at ${bin_path}"
    create_shim "${bin_path}" "${bin_name}"
  done
}

cmd_list_envs() {
  list_available_envs | awk -F"\t" '{printf "user: %s\t env: %s\t tarball: %s\n", $1, $2, $3}'
}

cmd_installed() {
  if [[ ! -s "$STATE_DB" ]]; then
    log "no fat envs installed (state db empty)"
    return
  fi
  log "installed fat envs (this user):"
  nl -ba "$STATE_DB" | sed 's/$/\n/'
}

cmd_installft() {
  local ident="$1"
  local tarball; tarball=$(find_env_tarball "$ident") || return 1
  # heuristics: env name
  local base; base=$(basename "$tarball")
  local envname
  if [[ "$base" =~ env-([a-zA-Z0-9._-]+) ]]; then
    envname="${BASH_REMATCH[1]}"
  else
    envname="${base%%.tar.*}"
  fi
  # find owner (user) from path
  local user
  if [[ "$tarball" =~ ^${SGOINFRE_BASE}/([^/]+)/ ]]; then
    user="${BASH_REMATCH[1]}"
  else
    user="local"
  fi
  log "Installing fat env '$envname' from $tarball (owner: $user)"
  extract_env_tarball "$tarball"
  # generate shims for env if placed under opt/envs
  if [[ -d "${JUNEST_ROOT}/opt/envs/${envname}" ]]; then
    local envdir="${JUNEST_ROOT}/opt/envs/${envname}"
    # list binaries
    local bins
    bins=$(find "$envdir" -type f -perm -u=x -printf "%p\n" | sed "s|${envdir}/||g" | tr '\n' ',' | sed 's/,$//') || bins=""
    # create shims for each exe in envdir/bin
    if [[ -d "$envdir/bin" ]]; then
      while IFS= read -r -d '' exe; do
        local exename; exename=$(basename "$exe")
        create_shim "/opt/envs/${envname}/bin/${exename}" "$exename"
      done < <(find "$envdir/bin" -type f -perm -u=x -print0 || true)
    fi
    state_add "$envname" "$user" "$tarball" "$bins"
    log "installed fat env '$envname'"
  else
    # fallback: best-effort shim generation from the whole junest root
    log "warning: env did not install under opt/envs/$envname â€” generated global shims where possible"
    # scan common dirs inside JUNEST_ROOT and create shims pointing to their absolute paths
    for sd in usr/bin usr/local/bin bin; do
      if [[ -d "${JUNEST_ROOT}/${sd}" ]]; then
        while IFS= read -r -d '' file; do
          local relpath="/${file#${JUNEST_ROOT}/}"
          local name; name=$(basename "$file")
          # if [[ -f "${SHIMS_DIR}/${name}" && ! grep -q '#june-shim' "${SHIMS_DIR}/${name}" ]]; then
          if [[ -f "${SHIMS_DIR}/${name}" ]] && ! grep -q '#june-shim' "${SHIMS_DIR}/${name}"; then
            continue
          fi
          cat > "${SHIMS_DIR}/${name}" <<EOF
#!/usr/bin/env bash
#june-shim
exec ${JUNEST_CMD} -- "${relpath}" "\$@"
EOF
          chmod +x "${SHIMS_DIR}/${name}"
        done < <(find "${JUNEST_ROOT}/${sd}" -type f -perm -u=x -print0 || true)
      fi
    done
    state_add "$envname" "$user" "$tarball" ""
  fi
}

cmd_uninstallft() {
  local env="$1"
  local entry; entry=$(state_find "$env")
  if [[ -z "$entry" ]]; then
    err "env '$env' not found in state db"
    return 1
  fi
  IFS='|' read -r _env _user _tar _when _bins <<< "$entry"
  # remove env dir under JUNEST_ROOT/opt/envs/<env>
  if [[ -d "${JUNEST_ROOT}/opt/envs/${env}" ]]; then
    log "removing ${JUNEST_ROOT}/opt/envs/${env}"
    rm -rf "${JUNEST_ROOT}/opt/envs/${env}"
  else
    log "no opt/envs/${env} dir found; doing best-effort cleanup"
  fi
  # remove shims created by june for that env (heuristic: shims contain '#june-shim' and point to /opt/envs/<env>)
  for s in "${SHIMS_DIR}"/*; do
    [[ -f "$s" ]] || continue
    if grep -q '#june-shim' "$s" && grep -q "/opt/envs/${env}" "$s"; then
      log "removing shim $s"
      rm -f "$s"
    fi
  done
  state_remove "$env" || true
  log "uninstalled env $env"
}

# Command dispatch
if (( $# < 1 )); then
  cat <<EOF
Usage: june <command> [args]
Commands:
  install <pkg>                      Install small package inside junest (calls yay/pacman)
  installft <env|user/env|tarpath>   Install a fat environment (tarball exposed under /sgoinfre/*/june/envs)
  uninstallft <env>                  Uninstall previously installed fat environment
  list-envs                          List fat envs exposed by other users (requires june.proof)
  installed                          List fat envs you have installed (session state)

Notes:
  - To expose envs for others, place tarballs under /sgoinfre/<youruser>/june/envs/ and
    create /sgoinfre/<youruser>/june/june.proof (an empty file is fine).
  - Fat env tarballs should ideally contain their files under opt/envs/<envname>/ for easy uninstall.
EOF
  exit 0
fi

case "$1" in
  install)
    (( $# == 2 )) || { err "install requires a package name"; exit 2; }
    cmd_install "$2" ;;
  installft)
    (( $# == 2 )) || { err "installft requires an env identifier"; exit 2; }
    cmd_installft "$2" ;;
  uninstallft)
    (( $# == 2 )) || { err "uninstallft requires an env name"; exit 2; }
    cmd_uninstallft "$2" ;;
  list-envs)
    cmd_list_envs ;;
  installed)
    cmd_installed ;;
  *)
    err "unknown command: $1"; exit 2 ;;
esac
