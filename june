#!/usr/bin/env bash
# june - prototype user-space package manager for junest environments
# Prototype features:
#  - june install <pkg>      : install package via yay (inside junest)
#  - june sync               : manually sync to sgoinfre
#  - june list               : list installed packages
#  - june remove <pkg>       : remove package
# Notes:
#  - June exists to solve the lack of a proper package managers for a group of students.
#  - The apps cannot be installed directly with sudo, the users of this app never has access to admin rights.
#  - The apps have to be installed in junest, and the junest config must be in ~/goinfre/june.
#  - ~/goinfre is a bind mount to /goinfre/<USER>, same for ~/sgoinfre to /sgoinfre/<USER>.
#  - The goinfre is a fast and large directory on the local machine, potentially deleted on logout.
#  - The sgoinfre is a network directory with infinite storage, but it's slowish, and sometimes is unreachable.
#  - The only other data accessible to users is their home, but its size limit is really small (10GB, not suitable for IDEs).
#  - The goal of june is to have the junest data permanently installed in sgoinfre, but copied at login to the goinfre and ready for use.
#  - Junest is for provides a separate environment to install apps, as well as the AUR, but native speeds. June is a wrapper to make it convenient for our use case.
#  - So to recap, the app (a startup script has yet to be made) must be able to when making changes to the junest environment, change the version present in the sgoinfre. Using a strong compression is recommended.
#  - Oh yeah, also june creates shims in order for the apps to be accessible through the host system.
#  - Eventually, we will have a way to patch some apps (maybe a different install command with a finite list of apps) that need special configuration to run properly, I'm thinking IDEs (bc they cannot be allowed to write to home for space problems), process monitors (bc /proc is different in Junest).

set -euo pipefail
IFS=$'\n\t'

# --- Configuration ---
SGOINFRE="${HOME}/sgoinfre"
GOINFRE="/tmp/goinfre"
JUNEST_ROOT="${GOINFRE}/junest-root"
JUNEST_ARCHIVE="${SGOINFRE}/junest-root.tar.zst"
JUNEST_LOCK="${SGOINFRE}/.junest.lock"
SHIMS_DIR="${HOME}/bin"
STATE_DB="${GOINFRE}/june-state.db"
JUNEST_CMD="$(command -v junest 2>/dev/null || true)"
YAY_CMD="yay --color=always"
# COMPRESS_CMD=(zstd -T0 -19)
COMPRESS_CMD=(zstd -T$(($(nproc) / 2)) --adapt)

# Set JUNEST_HOME environment variable
export JUNEST_HOME="$JUNEST_ROOT"

# Create dirs if needed
mkdir -p "$SHIMS_DIR" "$JUNEST_ROOT"

# --- Helpers ---
log() { printf '%s\n' "[june] $*"; }
err() { printf '%s\n' "[june] ERROR: $*" >&2; }

cleanup_lock() {
    rm -f "$JUNEST_LOCK"
}

acquire_lock() {
    local max_wait=60
    local waited=0
    
    while [[ -f "$JUNEST_LOCK" ]] && (( waited < max_wait )); do
        log "Waiting for another june operation to complete..."
        sleep 2
        ((waited += 2))
    done
    
    if [[ -f "$JUNEST_LOCK" ]]; then
        log "Lock timeout - removing stale lock"
        rm -f "$JUNEST_LOCK"
    fi
    
    echo "$$" > "$JUNEST_LOCK"
    trap cleanup_lock EXIT
}

sync_to_sgoinfre() {
    if [[ ! -d "$JUNEST_ROOT" ]]; then
        err "No local junest environment to sync"
        return 1
    fi
    
    log "Syncing junest environment to sgoinfre..."
    local temp_archive="${JUNEST_ARCHIVE}.tmp"
    
    # Check if pv is installed
    if ! command -v pv >/dev/null 2>&1; then
        err "pv command not found. Install pv for progress bar and ETA (e.g., sudo apt install pv)"
        # Fallback to original behavior without progress bar
        if ! tar -cf - -C "$GOINFRE" junest-root | "${COMPRESS_CMD[@]}" > "$temp_archive"; then
            err "Failed to compress junest environment"
            rm -f "$temp_archive"
            return 1
        fi
    else
        # Get the size of the directory to be compressed for pv
        local dir_size
        dir_size=$(du -sb "$JUNEST_ROOT" | cut -f1)
        
        # Create compressed archive with progress bar and ETA
        if ! tar -cf - -C "$GOINFRE" junest-root | pv -s "$dir_size" -petr | "${COMPRESS_CMD[@]}" > "$temp_archive"; then
            err "Failed to compress junest environment"
            rm -f "$temp_archive"
            return 1
        fi
    fi
    
    # Atomic move
    mv "$temp_archive" "$JUNEST_ARCHIVE"
    
    # Copy state file if exists
    if [[ -f "$STATE_DB" ]]; then
        cp "$STATE_DB" "${SGOINFRE}/june-state.db"
    fi
    
    local size=$(du -h "$JUNEST_ARCHIVE" | cut -f1)
    log "Junest environment saved to sgoinfre (compressed: $size)"
}

ensure_junest() {
    if [[ -z "$JUNEST_CMD" ]]; then
        err "junest not found in PATH. Install junest first."
        err "Run: curl -L https://github.com/fsquillace/junest/releases/download/8.1.0/junest -o ~/.local/bin/junest && chmod +x ~/.local/bin/junest"
        return 1
    fi
    
    if [[ ! -d "$JUNEST_ROOT" ]]; then
        err "Junest environment not initialized. Run june-startup first."
        return 1
    fi
    
    export JUNEST_HOME="$JUNEST_ROOT"
}

# create a shim in $SHIMS_DIR for an executable inside junest root
create_shim() {
    local target_path="$1"   # absolute path inside junest root
    local name="$2"
    local shim_file="${SHIMS_DIR}/${name}"
    cat > "$shim_file" <<EOF
#!/usr/bin/env bash
#june-shim
# Auto-generated by june
export JUNEST_HOME="${JUNEST_ROOT}"
exec ${JUNEST_CMD} -- "${target_path}" "\$@"
EOF
    chmod +x "$shim_file"
    log "shim created: $shim_file -> $target_path"
}

# Record installed package in state file
record_package() {
    local pkg="$1"
    local timestamp=$(date +%s)
    echo "${pkg}|${timestamp}|installed" >> "$STATE_DB"
}

# --- Commands ---
cmd_install() {
    local pkg="$1"
    ensure_junest || return 1
    
    acquire_lock
    
    log "Installing $pkg inside junest via yay/pacman..."
    log "Note: prefer '-bin' variants to avoid building from source."
    
    if [[ -n "$YAY_CMD" ]]; then
        ${JUNEST_CMD} -- ${YAY_CMD} -S --noconfirm "$pkg" || { 
            cleanup_lock
            err "install failed"
            return 1
        }
    else
        ${JUNEST_CMD} -- pacman -S --noconfirm "$pkg" || {
            cleanup_lock
            err "install failed"
            return 1
        }
    fi
    
    log "Install finished. Generating shims..."
    
    # Get list of binaries installed by the package
    local bins
    bins=$(${JUNEST_CMD} -- ${YAY_CMD} -Ql "$pkg" 2>/dev/null | grep -E '/(s?bin|opt/[^/]+/bin)/' | grep -v '/$' | awk '{print $2}' | sort -u)
    
    if [[ -z "$bins" ]]; then
        log "No executables found in package"
    else
        while IFS= read -r bin_path; do
            if [[ -n "$bin_path" ]]; then
                local bin_name=$(basename "$bin_path")
                create_shim "$bin_path" "$bin_name"
            fi
        done <<< "$bins"
    fi
    
    record_package "$pkg"
    sync_to_sgoinfre
    
    cleanup_lock
    log "Package $pkg installed and synced successfully!"
}

cmd_remove() {
    local pkg="$1"
    ensure_junest || return 1
    
    acquire_lock
    
    log "Removing $pkg from junest..."
    
    # Remove shims for this package first
    local bins
    bins=$(${JUNEST_CMD} -- ${YAY_CMD} -Ql "$pkg" 2>/dev/null | grep -E '/(s?bin|opt/[^/]+/bin)/' | grep -v '/$' | awk '{print $2}')
    
    while IFS= read -r bin_path; do
        if [[ -n "$bin_path" ]]; then
            local bin_name=$(basename "$bin_path")
            local shim_file="${SHIMS_DIR}/${bin_name}"
            if [[ -f "$shim_file" ]] && grep -q "#june-shim" "$shim_file" 2>/dev/null; then
                rm -f "$shim_file"
                log "Removed shim: $shim_file"
            fi
        fi
    done <<< "$bins"
    
    # Remove package
    ${JUNEST_CMD} -- ${YAY_CMD} -R --noconfirm "$pkg" || {
        cleanup_lock
        err "remove failed"
        return 1
    }
    
    # Update state
    echo "${pkg}|$(date +%s)|removed" >> "$STATE_DB"
    sync_to_sgoinfre
    
    cleanup_lock
    log "Package $pkg removed and changes synced!"
}

cmd_list() {
    ensure_junest || return 1
    
    log "Installed packages in junest:"
    ${JUNEST_CMD} -- ${YAY_CMD} -Q || ${JUNEST_CMD} -- pacman -Q
}

cmd_sync() {
    acquire_lock
    sync_to_sgoinfre
    cleanup_lock
}

cmd_search() {
    local query="$1"
    ensure_junest || return 1
    
    log "Searching for packages matching '$query'..."
    ${JUNEST_CMD} -- ${YAY_CMD} -Ss "$query" || ${JUNEST_CMD} -- pacman -Ss "$query"
}

cmd_update() {
    ensure_junest || return 1
    
    acquire_lock
    
    log "Updating package databases and installed packages..."
    ${JUNEST_CMD} -- ${YAY_CMD} -Syu --noconfirm || ${JUNEST_CMD} -- pacman -Syu --noconfirm
    
    sync_to_sgoinfre
    cleanup_lock
    
    log "System updated and synced!"
}

# Command dispatch
if (( $# < 1 )); then
    cat <<EOF
Usage: june <command> [args]

Commands:
  install <pkg>    Install package inside junest (auto-syncs to sgoinfre)
  remove <pkg>     Remove package from junest
  list            List installed packages
  search <query>  Search for packages
  update          Update all packages
  sync            Manually sync junest to sgoinfre

Examples:
  june install neovim-bin      # Install neovim (binary version)
  june install code-bin        # Install VS Code
  june search python           # Search for python packages
  june list                    # Show all installed packages
  
Note: Prefer '-bin' package variants to avoid compilation.
      Changes are automatically synced to sgoinfre after operations.
EOF
    exit 0
fi

case "$1" in
    install)
        (( $# == 2 )) || { err "install requires a package name"; exit 2; }
        cmd_install "$2" ;;
    remove|uninstall)
        (( $# == 2 )) || { err "remove requires a package name"; exit 2; }
        cmd_remove "$2" ;;
    list|ls)
        cmd_list ;;
    search|find)
        (( $# == 2 )) || { err "search requires a query"; exit 2; }
        cmd_search "$2" ;;
    update|upgrade)
        cmd_update ;;
    sync)
        cmd_sync ;;
    junest)
        ${JUNEST_CMD} ;;
    *)
        err "unknown command: $1"
        exit 2 ;;
esac
