#!/usr/bin/env bash
# june - prototype user-space package manager for junest environments
# Prototype features:
#  - june install <pkg>      : install package via yay (inside junest)
#  - june sync               : manually sync to sgoinfre
#  - june list               : list installed packages
#  - june remove <pkg>       : remove package
# Notes:
#  - June exists to solve the lack of a proper package managers for a group of students.
#  - The apps cannot be installed directly with sudo, the users of this app never has access to admin rights.
#  - The apps have to be installed in junest, and the junest config must be in ~/goinfre/june.
#  - ~/goinfre is a bind mount to /goinfre/<USER>, same for ~/sgoinfre to /sgoinfre/<USER>.
#  - The goinfre is a fast and large directory on the local machine, potentially deleted on logout.
#  - The sgoinfre is a network directory with infinite storage, but it's slowish, and sometimes is unreachable.
#  - The only other data accessible to users is their home, but its size limit is really small (10GB, not suitable for IDEs).
#  - The goal of june is to have the junest data permanently installed in sgoinfre, but copied at login to the goinfre and ready for use.
#  - Junest is for provides a separate environment to install apps, as well as the AUR, but native speeds. June is a wrapper to make it convenient for our use case.
#  - So to recap, the app (a startup script has yet to be made) must be able to when making changes to the junest environment, change the version present in the sgoinfre. Using a strong compression is recommended.
#  - Oh yeah, also june creates shims in order for the apps to be accessible through the host system.
#  - Eventually, we will have a way to patch some apps (maybe a different install command with a finite list of apps) that need special configuration to run properly, I'm thinking IDEs (bc they cannot be allowed to write to home for space problems), process monitors (bc /proc is different in Junest).

set -euo pipefail
IFS=$'\n\t'

# --- Configuration ---
SGOINFRE="${HOME}/sgoinfre"
GOINFRE="/tmp/goinfre"
JUNEST_ROOT="${GOINFRE}/junest-root"
JUNEST_ARCHIVE="${SGOINFRE}/junest-root.tar.zst"
JUNEST_LOCK="${SGOINFRE}/.junest.lock"
SHIMS_DIR="${HOME}/bin"
STATE_DB="${GOINFRE}/june-state.db"
JUNEST_CMD="$(command -v junest 2>/dev/null || true)"
YAY_CMD="yay"
COMPRESS_CMD=(zstd -T$(($(nproc) / 2)) --adapt)

# Check if stdout is a terminal for color output
if [[ -t 1 ]]; then
    USE_COLORS=1
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    GRAY=$(tput setaf 8)
    NC=$(tput sgr0)
else
    USE_COLORS=0
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Set JUNEST_HOME environment variable
export JUNEST_HOME="$JUNEST_ROOT"

# Create dirs if needed
mkdir -p "$SHIMS_DIR" "$JUNEST_ROOT"

# --- Helpers ---
log() { printf "${BLUE}[june]${NC} %s\n" "$*"; }
err() { printf "${RED}[june] ERROR: %s${NC}\n" "$*" >&2; }

cleanup_lock() {
    rm -f "$JUNEST_LOCK"
}

acquire_lock() {
    local max_wait=60
    local waited=0
    
    while [[ -f "$JUNEST_LOCK" ]] && (( waited < max_wait )); do
        log "Waiting for another june operation to complete..."
        sleep 2
        ((waited += 2))
    done
    
    if [[ -f "$JUNEST_LOCK" ]]; then
        log "Lock timeout - removing stale lock"
        rm -f "$JUNEST_LOCK"
    fi
    
    echo "$$" > "$JUNEST_LOCK"
    trap cleanup_lock EXIT
}

sync_to_sgoinfre() {
    if [[ ! -d "$JUNEST_ROOT" ]]; then
        err "No local junest environment to sync"
        return 1
    fi
    
    log "Syncing junest environment to ${YELLOW}sgoinfre${NC}..."
    local temp_archive="${JUNEST_ARCHIVE}.tmp"
    
    if ! command -v pv >/dev/null 2>&1; then
        err "pv command not found. Install pv for progress bar and ETA (e.g., sudo apt install pv)"
        if ! tar -cf - -C "$GOINFRE" junest-root | "${COMPRESS_CMD[@]}" > "$temp_archive"; then
            err "Failed to compress junest environment"
            rm -f "$temp_archive"
            return 1
        fi
    else
        local dir_size
        dir_size=$(du -sb "$JUNEST_ROOT" | cut -f1)
        if ! tar -cf - -C "$GOINFRE" junest-root | pv -s "$dir_size" -petr | "${COMPRESS_CMD[@]}" > "$temp_archive"; then
            err "Failed to compress junest environment"
            rm -f "$temp_archive"
            return 1
        fi
    fi
    
    mv "$temp_archive" "$JUNEST_ARCHIVE"
    
    if [[ -f "$STATE_DB" ]]; then
        cp "$STATE_DB" "${SGOINFRE}/june-state.db"
    fi
    
    local size=$(du -h "$JUNEST_ARCHIVE" | cut -f1)
    log "Junest environment saved to ${YELLOW}sgoinfre${NC} (compressed: $size)"
}

ensure_junest() {
    if [[ -z "$JUNEST_CMD" ]]; then
        err "junest not found in PATH. Install junest first."
        err "Run: curl -L https://github.com/fsquillace/junest/releases/download/8.1.0/junest -o ~/.local/bin/junest && chmod +x ~/.local/bin/junest"
        return 1
    fi
    
    if [[ ! -d "$JUNEST_ROOT" ]]; then
        err "Junest environment not initialized. Run june-startup first."
        return 1
    fi
    
    export JUNEST_HOME="$JUNEST_ROOT"
}

create_shim() {
    local target_path="$1"
    local name="$2"
    local shim_file="${SHIMS_DIR}/${name}"
    cat > "$shim_file" <<EOF
#!/usr/bin/env bash
#june-shim
# Auto-generated by june
export JUNEST_HOME="${JUNEST_ROOT}"
exec ${JUNEST_CMD} -- "${target_path}" "\$@"
EOF
    chmod +x "$shim_file"
    log "shim created: ${GREEN}$shim_file${NC} -> $target_path"
}

record_package() {
    local pkg="$1"
    local timestamp=$(date +%s)
    echo "${pkg}|${timestamp}|installed" >> "$STATE_DB"
}

# --- Commands ---
cmd_install() {
    local pkg="$1"
    ensure_junest || return 1
    
    acquire_lock
    
    log "Installing ${GREEN}$pkg${NC} inside junest via yay/pacman..."
    log "Note: prefer '-bin' and avoid 'git' variants to avoid building from source."
    
    if [[ -n "$YAY_CMD" ]]; then
        ${JUNEST_CMD} -- ${YAY_CMD} --color=auto -S --noconfirm "$pkg" || { 
            cleanup_lock
            err "install failed"
            return 1
        }
    else
        ${JUNEST_CMD} -- pacman -S --noconfirm "$pkg" || {
            cleanup_lock
            err "install failed"
            return 1
        }
    fi
    
    log "Install finished. Generating shims..."
    
    local bins
    bins=$(${JUNEST_CMD} -- ${YAY_CMD} --color=auto -Ql "$pkg" 2>/dev/null | grep -E '/(s?bin|opt/[^/]+/bin)/' | grep -v '/$' | awk '{print $2}' | sort -u)
    
    if [[ -z "$bins" ]]; then
        log "No executables found in package"
    else
        while IFS= read -r bin_path; do
            if [[ -n "$bin_path" ]]; then
                local bin_name=$(basename "$bin_path")
                create_shim "$bin_path" "$bin_name"
            fi
        done <<< "$bins"
    fi
    
    record_package "$pkg"
    sync_to_sgoinfre
    
    cleanup_lock
    log "Package ${GREEN}$pkg${NC} installed and synced successfully!"
}

cmd_remove() {
    local pkg="$1"
    ensure_junest || return 1
    
    acquire_lock
    
    log "Removing ${RED}$pkg${NC} from junest..."
    
    local bins
    bins=$(${JUNEST_CMD} -- ${YAY_CMD} --color=auto -Ql "$pkg" 2>/dev/null | grep -E '/(s?bin|opt/[^/]+/bin)/' | grep -v '/$' | awk '{print $2}')
    
    while IFS= read -r bin_path; do
        if [[ -n "$bin_path" ]]; then
            local bin_name=$(basename "$bin_path")
            local shim_file="${SHIMS_DIR}/${bin_name}"
            if [[ -f "$shim_file" ]] && grep -q "#june-shim" "$shim_file" 2>/dev/null; then
                rm -f "$shim_file"
                log "Removed shim: ${RED}$shim_file${NC}"
            fi
        fi
    done <<< "$bins"
    
    ${JUNEST_CMD} -- ${YAY_CMD} --color=auto -R --noconfirm "$pkg" || {
        cleanup_lock
        err "remove failed"
        return 1
    }
    
    echo "${pkg}|$(date +%s)|removed" >> "$STATE_DB"
    sync_to_sgoinfre
    
    cleanup_lock
    log "Package ${RED}$pkg${NC} removed and changes synced!"
}

cmd_sync() {
    acquire_lock
    sync_to_sgoinfre
    cleanup_lock
}

cmd_list() {
    ensure_junest || return 1
    
    log "Listing installed packages in junest..."
    ${JUNEST_CMD} -- ${YAY_CMD} --color=auto -Q || ${JUNEST_CMD} -- pacman -Q
}

cmd_search() {
    local query="$1"
    ensure_junest || return 1
    
    log "Searching for packages matching '${YELLOW}$query${NC}'..."
    ${JUNEST_CMD} -- ${YAY_CMD} --color=auto -Ss "$query" || ${JUNEST_CMD} -- pacman -Ss "$query"
}

cmd_update() {
    ensure_junest || return 1
    
    acquire_lock
    
    log "Updating package databases and installed packages..."
    ${JUNEST_CMD} -- ${YAY_CMD} --color=auto -Syu --noconfirm || ${JUNEST_CMD} -- pacman -Syu --noconfirm
    
    sync_to_sgoinfre
    cleanup_lock
    
    log "${GREEN}System updated and synced!${NC}"
}

# Command dispatch
if (( $# < 1 )); then
    printf "${BLUE}Usage:${NC} june <command> [args]\n\n"
    printf "${YELLOW}Commands:${NC}\n"
    printf "  ${BLUE}install ${GREEN}<pkg>${NC}   Install package inside junest (auto-syncs to sgoinfre)\n"
    printf "  ${BLUE}remove ${GREEN}<pkg>${NC}    Remove package from junest\n"
    printf "  ${BLUE}list${NC}            List installed packages\n"
    printf "  ${BLUE}search${GREEN} <query>${NC}  Search for packages\n"
    printf "  ${BLUE}update${NC}          Update all packages\n"
    printf "  ${BLUE}sync${NC}            Manually sync junest to sgoinfre\n\n"
    printf "${YELLOW}Examples:${NC}\n"
    printf "  june ${BLUE}install ${GREEN}neovim-bin${NC}      ${GRAY}# Install neovim (binary version)${NC}\n"
    printf "  june ${BLUE}install ${GREEN}code-bin${NC}        ${GRAY}# Install VS Code${NC}\n"
    printf "  june ${BLUE}search ${GREEN}python${NC}           ${GRAY}# Search for python packages${NC}\n"
    printf "  june ${BLUE}list${NC}                    ${GRAY}# Show all installed packages${NC}\n\n"
    printf "${YELLOW}Note:${NC} Prefer '-bin' and avoid '-git' package variants to avoid compilation.\n"
    printf "      Changes are automatically synced to sgoinfre after operations.\n"
    exit 0
fi

case "$1" in
    install)
        (( $# == 2 )) || { err "install requires a package name"; exit 2; }
        cmd_install "$2" ;;
    remove|uninstall)
        (( $# == 2 )) || { err "remove requires a package name"; exit 2; }
        cmd_remove "$2" ;;
    list|ls)
        cmd_list ;;
    search|find)
        (( $# == 2 )) || { err "search requires a query"; exit 2; }
        cmd_search "$2" ;;
    update|upgrade)
        cmd_update ;;
    sync)
        cmd_sync ;;
    junest)
        ${JUNEST_CMD} ;;
    *)
        err "unknown command: $1"
        exit 2 ;;
esac
